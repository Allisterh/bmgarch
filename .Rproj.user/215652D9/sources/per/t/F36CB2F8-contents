#' Standardize input data to facilitate computation
#' 
#' @param data Time-series data
#' @param ahead Number of periods forecasting ahead
#'
#' @return bmgarch object 
#' @export
#' @keywords internal
standat = function(data, ahead){
    if(dim(data)[1] < dim(data)[2]) data = t(data)
    ## Standardize time-series
    stdx = scale(data)
    data_center = attr(stdx, "scaled:center")
    data_scale = attr(stdx, "scaled:scale")
    list( list(T = nrow(stdx), rts = stdx, sigma1 = cov(stdx), nt = ncol(stdx), ahead = ahead), list(data_center, data_scale) )
}

##' Draw samples from a specified multivariate GARCH model, given multivariate time-series.
##'
##' Three paramerization are implemented. The constant conditinal correlation (CCC), the dynamic conditional correlatoin (DCC), and the BEKK.
##' @title Bayesian Multivariate GARCH
##' @param data A time-series or matrix object containing observations at the same interval.
##' @param parameterization A character string specifying the type of of parameterization, must be one of "CCC" (default), "DCC", or "BEKK".
##' @param ahead A number specifying the number of forecasted periods. Defaults to 1.
##' @param iterations A positive integer specifying the number of iterations for each chain (including warmup). The default is 1000
##' @param chains A positive integer specifying the number of Markov chains. The default is 4.
##' @param ... Additional arguments can be ‘chain_id’, ‘init_r’, ‘test_grad’, ‘append_samples’, ‘refresh’, ‘enable_random_init’. See the documentation in ‘stan’.
##' @return An object of S4 class ‘stanfit’ representing the fitted results.
##' @author philippe
bmgarch = function(data, parameterization = 'CCC', ahead = 1, iterations = 1000, chains = 4, ...){
    stan_data  = standat(data, ahead)[[1]]
    data_moments = standat(data, ahead)[[2]]
  if(parameterization == 'CCC') model_fit <- rstan::sampling(stanmodels$CCCMGARCH, data = stan_data,
                                                      verbose = TRUE,
                                                      iter = iterations,
                                                      control = list(adapt_delta = .99),
                                                      init_r = 1,
                                                      chains = chains) else {
  if( parameterization == 'DCC' ) model_fit <- rstan::sampling(stanmodels$DCCMGARCH, data = stan_data,
                                                      verbose = TRUE,
                                                      iter = iterations,
                                                      control = list(adapt_delta = .99),
                                                      init_r = 1,
                                                      chains = chains) else {
  if( parameterization == 'BEKK' ) model_fit <- rstan::sampling(stanmodels$BEKKMGARCH, data = stan_data,
                                                      verbose = TRUE,
                                                      iter = iterations,
                                                      control = list(adapt_delta = .99),
                                                      init_r = 1,
                                                      chains = chains) else {
  return( 'Not a valid model specification. Select CCC, DCC, or BEKK.' )}
      }                                                                 }
    ## Model fit is based on standardized values.
    mns = data_moments[[1]]
    sds = data_moments[[2]]
    ## Values could be converted to original scale using something like this on the estimates
    ## orig_sd = stan_data$rts %*% diag(sds)
    ## orig_scale = orig_sd + array(rep(mns, each = aussi[[1]]$T), dim = c(aussi[[1]]$T, aussi[[1]]$nt) )
 return( list(model_fit, parameterization) )
}
